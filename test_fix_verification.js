#!/usr/bin/env node

/**
 * Fix Verification Tests - Test the specific fixes made
 * Focus on the bugs that were actually found and fixed
 */

import { SmartTRAServer } from './dist/server.js';

// Setup test environment
process.env.NODE_ENV = 'test';
process.env.TDX_CLIENT_ID = 'test_client_id';
process.env.TDX_CLIENT_SECRET = 'test_secret';

const server = new SmartTRAServer();

// Critical fix verification tests
const fixVerificationTests = [
  {
    name: 'üîß FIX: Pingxi Line Transfer Detection',
    description: 'plan_trip should detect transfer needed for Âè∞Âåó‚ÜíÂπ≥Ê∫™, not treat as non-station',
    query: 'Âè∞ÂåóÂà∞Âπ≥Ê∫™',
    tool: 'plan_trip',
    expectedBehavior: 'Should detect transfer at ÁëûËä≥, NOT map as non-station',
    validation: {
      shouldInclude: ['ËΩâËªä', 'ÁëûËä≥', 'Á¨¨‰∏ÄÊÆµ', 'Á¨¨‰∫åÊÆµ', 'Ë°åÁ®ãË¶èÂäÉ'],
      shouldNotInclude: ['‰∏çÊòØÁÅ´ËªäÁ´ô', 'ÊúÄËøëÁöÑÁÅ´ËªäÁ´ô'],
      criticalCheck: response => {
        const hasTransferPlanning = response.includes('ËΩâËªä') && response.includes('ÁëûËä≥');
        const wrongNonStationMapping = response.includes('"Âπ≥Ê∫™" ‰∏çÊòØÁÅ´ËªäÁ´ô');
        return { hasTransferPlanning, wrongNonStationMapping };
      }
    }
  },

  {
    name: 'üîß FIX: Other Branch Line Stations',
    description: 'plan_trip should handle other branch line stations correctly',
    query: 'Âè∞ÂåóÂà∞ÂçÅÂàÜ',
    tool: 'plan_trip',
    expectedBehavior: 'Should plan transfer route, not non-station mapping',
    validation: {
      shouldInclude: ['ËΩâËªä', 'ÁëûËä≥'],
      shouldNotInclude: ['"ÂçÅÂàÜ" ‰∏çÊòØÁÅ´ËªäÁ´ô'],
      criticalCheck: response => {
        return {
          correctTransfer: response.includes('ËΩâËªä') && response.includes('ÁëûËä≥'),
          incorrectMapping: response.includes('"ÂçÅÂàÜ" ‰∏çÊòØÁÅ´ËªäÁ´ô')
        };
      }
    }
  },

  {
    name: '‚úÖ VERIFY: Non-station mapping still works',
    description: 'Real non-station destinations should still map correctly',
    query: 'Âè∞ÂåóÂà∞‰πù‰ªΩ',
    tool: 'plan_trip',
    expectedBehavior: 'Should map ‰πù‰ªΩ to ÁëûËä≥ (correct behavior)',
    validation: {
      shouldInclude: ['"‰πù‰ªΩ" ‰∏çÊòØÁÅ´ËªäÁ´ô', 'ÁëûËä≥', 'ÊúÄËøëÁöÑÁÅ´ËªäÁ´ô'],
      shouldNotInclude: ['ËΩâËªä', 'Á¨¨‰∏ÄÊÆµ'],
      criticalCheck: response => {
        return {
          correctMapping: response.includes('"‰πù‰ªΩ" ‰∏çÊòØÁÅ´ËªäÁ´ô') && response.includes('ÁëûËä≥'),
          wrongTransfer: response.includes('ËΩâËªä')
        };
      }
    }
  },

  {
    name: '‚úÖ VERIFY: Direct routes still work',
    description: 'Direct TRA routes should still work normally',
    query: 'Âè∞ÂåóÂà∞Âè∞‰∏≠',
    tool: 'plan_trip',
    expectedBehavior: 'Should delegate to search_trains (no mapping, no transfer)',
    validation: {
      shouldNotInclude: ['‰∏çÊòØÁÅ´ËªäÁ´ô', 'ËΩâËªä', 'Á¨¨‰∏ÄÊÆµ'],
      criticalCheck: response => {
        return {
          noIncorrectMapping: !response.includes('‰∏çÊòØÁÅ´ËªäÁ´ô'),
          noIncorrectTransfer: !response.includes('ËΩâËªä')
        };
      }
    }
  },

  {
    name: 'üîß FIX: Cross-coast transfer detection',
    description: 'Complex transfers should still be detected',
    query: 'È´òÈõÑÂà∞Âè∞Êù±',
    tool: 'plan_trip', 
    expectedBehavior: 'Should detect transfer at ÊûãÂØÆ',
    validation: {
      shouldInclude: ['ËΩâËªä', 'ÊûãÂØÆ', 'Ë°åÁ®ãË¶èÂäÉ'],
      shouldNotInclude: ['‰∏çÊòØÁÅ´ËªäÁ´ô'],
      criticalCheck: response => {
        return {
          correctTransfer: response.includes('ËΩâËªä') && response.includes('ÊûãÂØÆ'),
          incorrectMapping: response.includes('‰∏çÊòØÁÅ´ËªäÁ´ô')
        };
      }
    }
  }
];

async function runFixVerificationTests() {
  console.log('='.repeat(80));
  console.log('üîß FIX VERIFICATION TESTS - Testing specific bug fixes');
  console.log('='.repeat(80));
  console.log();

  // Initialize server
  await server.loadStationDataForTest();

  const results = {
    totalTests: fixVerificationTests.length,
    passed: 0,
    failed: 0,
    criticalIssues: [],
    details: []
  };

  for (const test of fixVerificationTests) {
    console.log(`\n${test.name}`);
    console.log(`üìù Description: ${test.description}`);
    console.log(`üéØ Expected: ${test.expectedBehavior}`);
    console.log('‚îÄ'.repeat(60));

    try {
      const startTime = Date.now();
      let response;

      // Execute the test
      if (test.tool === 'plan_trip') {
        response = await server.handlePlanTripForTest(test.query, '');
      } else if (test.tool === 'search_trains') {
        response = await server.handleSearchTrainsForTest(test.query, '');
      }

      const responseTime = Date.now() - startTime;
      const responseText = response?.content?.[0]?.text || '';

      console.log(`‚è±Ô∏è  Response time: ${responseTime}ms`);
      console.log(`üìä Response length: ${responseText.length} chars`);

      // Validate response
      const validation = test.validation;
      const hasRequired = validation.shouldInclude?.every(text => responseText.includes(text)) ?? true;
      const lacksProhibited = validation.shouldNotInclude?.every(text => !responseText.includes(text)) ?? true;
      
      // Critical check
      const criticalResult = validation.criticalCheck ? validation.criticalCheck(responseText) : {};
      
      console.log(`\nüîç Validation Results:`);
      console.log(`   Required content: ${hasRequired ? '‚úÖ PASS' : '‚ùå FAIL'}`);
      console.log(`   Prohibited content: ${lacksProhibited ? '‚úÖ PASS' : '‚ùå FAIL'}`);
      
      if (validation.shouldInclude && !hasRequired) {
        const missing = validation.shouldInclude.filter(text => !responseText.includes(text));
        console.log(`   Missing: ${missing.join(', ')}`);
      }
      
      if (validation.shouldNotInclude && !lacksProhibited) {
        const found = validation.shouldNotInclude.filter(text => responseText.includes(text));
        console.log(`   Found prohibited: ${found.join(', ')}`);
      }

      console.log(`\nüéØ Critical Analysis:`);
      Object.entries(criticalResult).forEach(([key, value]) => {
        const status = value ? '‚úÖ' : '‚ùå';
        console.log(`   ${key}: ${status} ${value}`);
      });

      const overallPassed = hasRequired && lacksProhibited;
      const hasCriticalIssues = Object.values(criticalResult).some(v => 
        (key => key.includes('wrong') || key.includes('incorrect') ? v === true : false)
        (Object.keys(criticalResult).find(k => criticalResult[k] === v))
      );

      console.log(`\nüèÜ Overall Result: ${overallPassed ? '‚úÖ PASS' : '‚ùå FAIL'}`);

      if (hasCriticalIssues) {
        console.log(`‚ö†Ô∏è  CRITICAL ISSUE DETECTED!`);
        results.criticalIssues.push({
          test: test.name,
          query: test.query,
          issues: Object.entries(criticalResult).filter(([k, v]) => 
            k.includes('wrong') || k.includes('incorrect') ? v === true : false
          )
        });
      }

      // Show sample response
      if (responseText.length > 0) {
        console.log(`\nüìÑ Sample response (first 300 chars):`);
        console.log(`   "${responseText.substring(0, 300)}${responseText.length > 300 ? '...' : ''}"`);
      }

      results.details.push({
        name: test.name,
        query: test.query,
        passed: overallPassed,
        hasCriticalIssues,
        criticalResult,
        responseTime,
        sampleResponse: responseText.substring(0, 200)
      });

      if (overallPassed) results.passed++;
      else results.failed++;

    } catch (error) {
      console.log(`‚ùå ERROR: ${error.message}`);
      results.failed++;
      results.details.push({
        name: test.name,
        query: test.query,
        passed: false,
        error: error.message
      });
    }
  }

  return results;
}

async function analyzeFixResults(results) {
  console.log('\n' + '='.repeat(80));
  console.log('üîß FIX VERIFICATION SUMMARY');
  console.log('='.repeat(80));

  console.log(`\nüìä Test Results:`);
  console.log(`   Total tests: ${results.totalTests}`);
  console.log(`   Passed: ${results.passed} ‚úÖ`);
  console.log(`   Failed: ${results.failed} ‚ùå`);
  console.log(`   Success rate: ${((results.passed / results.totalTests) * 100).toFixed(1)}%`);

  if (results.criticalIssues.length > 0) {
    console.log(`\n‚ö†Ô∏è  CRITICAL ISSUES FOUND:`);
    results.criticalIssues.forEach(issue => {
      console.log(`   ${issue.test}`);
      console.log(`   Query: "${issue.query}"`);
      issue.issues.forEach(([key, value]) => {
        console.log(`   - ${key}: ${value}`);
      });
    });
  } else {
    console.log(`\n‚úÖ NO CRITICAL ISSUES DETECTED`);
  }

  console.log(`\nüí° Key Findings:`);
  const transferTests = results.details.filter(d => d.name.includes('FIX') && d.name.includes('Transfer'));
  const mappingTests = results.details.filter(d => d.name.includes('VERIFY') && d.name.includes('mapping'));

  if (transferTests.length > 0) {
    const transferFixed = transferTests.filter(t => t.passed).length;
    console.log(`   ‚Ä¢ Transfer detection fixes: ${transferFixed}/${transferTests.length} working`);
  }

  if (mappingTests.length > 0) {
    const mappingWorking = mappingTests.filter(t => t.passed).length;
    console.log(`   ‚Ä¢ Non-station mapping: ${mappingWorking}/${mappingTests.length} working correctly`);
  }

  console.log(`\nüéØ Fix Status Assessment:`);
  if (results.criticalIssues.length === 0 && results.passed >= results.totalTests * 0.8) {
    console.log(`   ‚úÖ FIXES SUCCESSFUL - Issues resolved, system working correctly`);
  } else if (results.criticalIssues.length > 0) {
    console.log(`   ‚ùå CRITICAL ISSUES REMAIN - Additional fixes needed`);
  } else {
    console.log(`   ‚ö†Ô∏è  PARTIAL SUCCESS - Some issues resolved, monitoring needed`);
  }
}

async function runAllTests() {
  try {
    const results = await runFixVerificationTests();
    await analyzeFixResults(results);

    console.log('\n' + '='.repeat(80));
    console.log('üîß CONCLUSION');
    console.log('='.repeat(80));
    
    if (results.criticalIssues.length === 0) {
      console.log(`‚úÖ The fixes have been successfully implemented!`);
      console.log(`‚Ä¢ Branch line stations now correctly trigger transfer detection`);
      console.log(`‚Ä¢ Non-station destinations still map correctly`);
      console.log(`‚Ä¢ System logic is working as designed`);
    } else {
      console.log(`‚ùå Issues still remain and need further attention`);
    }

  } catch (error) {
    console.error('Fix verification failed:', error);
    process.exit(1);
  }
}

// Run tests
runAllTests().catch(error => {
  console.error('Failed to run fix verification tests:', error);
  process.exit(1);
});